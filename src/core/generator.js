/**
 * AIOS Nexus - Content Generator
 *
 * AI-powered content generation for context
 * Version: 5.0.0
 */

const fs = require('fs-extra');
const path = require('path');
const chalk = require('chalk');

class ContentGenerator {
  constructor(config = {}) {
    this.config = {
      root: config.root || process.cwd(),
      contextRoot: config.contextRoot || path.join(process.cwd(), '.context'),
      llm: config.llm,
      ...config,
    };

    this.llm = config.llm;
  }

  /**
   * Generate documentation content
   */
  async generateDocs(analysis) {
    const docs = {};

    // Generate project overview
    docs['project-overview'] = await this.generateProjectOverview(analysis);

    // Generate architecture doc
    docs['architecture'] = await this.generateArchitectureDoc(analysis);

    // Generate tech stack doc
    docs['tech-stack'] = await this.generateTechStackDoc(analysis);

    return docs;
  }

  /**
   * Generate project overview
   */
  async generateProjectOverview(analysis) {
    const { techStack, structure } = analysis;

    let content = `# Project Overview

> Generated: ${new Date().toISOString()}

---

## Summary

This is a **${techStack.frameworks[0] || 'custom'}** project built with **${techStack.languages.join(' and ') || 'JavaScript'}**.

---

## Project Type

**${structure.type}**

${structure.architecture ? `Architecture: ${structure.architecture}` : ''}

---

## Key Technologies

### Frameworks
${techStack.frameworks.map((f) => `- ${f}`).join('\n') || '- None detected'}

### Languages
${techStack.languages.map((l) => `- ${l}`).join('\n') || '- JavaScript'}

### Databases
${techStack.databases.map((d) => `- ${d}`).join('\n') || '- None detected'}

### Styling
${techStack.styling.map((s) => `- ${s}`).join('\n') || '- CSS'}

### Testing
${techStack.testing.map((t) => `- ${t}`).join('\n') || '- None detected'}

---

## Project Structure

\`\`\`
${this.generateStructureTree(structure.directories)}
\`\`\`

---

## Entry Points

${structure.entryPoints.map((e) => `- \`${e}\``).join('\n') || '- Not detected'}

---

## Development Setup

\`\`\`bash
# Install dependencies
${this.getInstallCommand(analysis)}

# Start development
${this.getDevCommand(analysis)}

# Run tests
${this.getTestCommand(analysis)}
\`\`\`

---

*Generated by AIOS Nexus v5.0.0*
`;

    return content;
  }

  /**
   * Generate architecture document
   */
  async generateArchitectureDoc(analysis) {
    const { structure, patterns, symbols } = analysis;

    let content = `# Architecture

> Generated: ${new Date().toISOString()}

---

## Overview

**Project Type:** ${structure.type}

**Architecture Pattern:** ${structure.architecture || 'Standard'}

---

## Detected Patterns

${patterns.map((p) => `- **${p}**`).join('\n') || '- No specific patterns detected'}

---

## Directory Structure

| Directory | Purpose |
|-----------|---------|
${this.generateDirectoryTable(structure.directories)}

---

## Key Components

### Classes (${symbols.classes.length} detected)
${
  symbols.classes
    .slice(0, 10)
    .map((c) => `- \`${c.name}\` (${c.file})`)
    .join('\n') || '- None detected'
}

### Functions (${symbols.functions.length} detected)
${
  symbols.functions
    .slice(0, 10)
    .map((f) => `- \`${f.name}\` (${f.file})`)
    .join('\n') || '- None detected'
}

### Interfaces (${symbols.interfaces.length} detected)
${
  symbols.interfaces
    .slice(0, 10)
    .map((i) => `- \`${i.name}\` (${i.file})`)
    .join('\n') || '- None detected'
}

---

## Dependencies

**Total:** ${analysis.dependencies?.total || 0} packages

### Production Dependencies
${
  analysis.dependencies?.production
    .slice(0, 20)
    .map((d) => `- ${d}`)
    .join('\n') || '- None'
}

### Development Dependencies
${
  analysis.dependencies?.development
    .slice(0, 20)
    .map((d) => `- ${d}`)
    .join('\n') || '- None'
}

---

*Generated by AIOS Nexus v5.0.0*
`;

    return content;
  }

  /**
   * Generate tech stack document
   */
  async generateTechStackDoc(analysis) {
    const { techStack } = analysis;

    let content = `# Tech Stack

> Generated: ${new Date().toISOString()}

---

## Runtime

| Component | Version/Details |
|-----------|----------------|
| Node.js | ${techStack.nodeVersion || 'Not specified'} |
| Package Manager | ${techStack.packageManager} |

---

## Frameworks

${
  techStack.frameworks
    .map(
      (f) => `### ${f}

Detected framework: ${f}
`
    )
    .join('\n') || 'No frameworks detected.'
}

---

## Languages

${techStack.languages.map((l) => `- **${l}**`).join('\n') || '- JavaScript'}

---

## Databases

${techStack.databases.map((d) => `- **${d}**`).join('\n') || '- None detected'}

---

## Styling

${techStack.styling.map((s) => `- **${s}**`).join('\n') || '- CSS'}

---

## Testing

${techStack.testing.map((t) => `- **${t}**`).join('\n') || '- None detected'}

---

## Development Tools

${techStack.tools.map((t) => `- **${t}**`).join('\n') || '- None detected'}

---

*Generated by AIOS Nexus v5.0.0*
`;

    return content;
  }

  /**
   * Generate agent recommendations
   */
  async generateAgentRecommendations(analysis) {
    const { techStack, patterns } = analysis;
    const recommendations = [];

    // Always recommend orchestrator for coordination
    recommendations.push({
      agent: 'orchestrator',
      reason: 'Central coordination for all workflows',
      priority: 'high',
    });

    // Recommend based on tech stack
    if (techStack.frameworks.some((f) => ['react', 'next.js', 'vue', 'angular'].includes(f))) {
      recommendations.push({
        agent: 'developer',
        reason: 'Frontend framework detected',
        priority: 'high',
      });
    }

    if (techStack.frameworks.some((f) => ['express', 'nestjs', 'fastify'].includes(f))) {
      recommendations.push({
        agent: 'developer',
        reason: 'Backend framework detected',
        priority: 'high',
      });
    }

    if (techStack.databases.length > 0) {
      recommendations.push({
        agent: 'data-engineer',
        reason: 'Database integration detected',
        priority: 'medium',
      });
    }

    if (techStack.testing.length > 0) {
      recommendations.push({
        agent: 'qa',
        reason: 'Testing framework detected',
        priority: 'medium',
      });
    }

    // Add standard recommendations
    recommendations.push({
      agent: 'architect',
      reason: 'Architecture decisions and reviews',
      priority: 'medium',
    });

    recommendations.push({
      agent: 'reviewer',
      reason: 'Code review and quality',
      priority: 'medium',
    });

    return recommendations;
  }

  /**
   * Generate skill recommendations
   */
  async generateSkillRecommendations(analysis) {
    const { techStack, patterns } = analysis;
    const recommendations = [];

    // Frontend skills
    if (techStack.frameworks.includes('react') || techStack.frameworks.includes('next.js')) {
      recommendations.push({
        category: 'frontend',
        skill: 'react-nextjs',
        reason: 'React/Next.js framework detected',
      });
    }

    if (techStack.styling.includes('tailwindcss')) {
      recommendations.push({
        category: 'frontend',
        skill: 'tailwind',
        reason: 'Tailwind CSS detected',
      });
    }

    // Backend skills
    if (techStack.frameworks.includes('nestjs')) {
      recommendations.push({
        category: 'backend',
        skill: 'nestjs',
        reason: 'NestJS framework detected',
      });
    }

    if (techStack.frameworks.includes('express')) {
      recommendations.push({
        category: 'backend',
        skill: 'nodejs',
        reason: 'Node.js/Express detected',
      });
    }

    // Database skills
    if (techStack.databases.includes('prisma')) {
      recommendations.push({
        category: 'database',
        skill: 'prisma',
        reason: 'Prisma ORM detected',
      });
    }

    if (techStack.databases.includes('supabase')) {
      recommendations.push({
        category: 'database',
        skill: 'supabase',
        reason: 'Supabase detected',
      });
    }

    // Testing skills
    if (techStack.testing.length > 0) {
      recommendations.push({
        category: 'quality',
        skill: 'testing-patterns',
        reason: 'Testing frameworks detected',
      });
    }

    return recommendations;
  }

  /**
   * Generate workflow recommendations
   */
  async generateWorkflowRecommendations(analysis) {
    const recommendations = [];

    recommendations.push({
      workflow: 'feature-development',
      scale: 'MEDIUM',
      reason: 'Default for new features',
    });

    if (analysis.techStack.databases.length > 0) {
      recommendations.push({
        workflow: 'data-migration',
        scale: 'MEDIUM',
        reason: 'Database changes require careful planning',
      });
    }

    return recommendations;
  }

  /**
   * Generate specific file content
   */
  async generateFile(targetType, fileName, analysis, options = {}) {
    switch (targetType) {
      case 'docs':
        return (await this.generateDocs(analysis)[fileName]) || null;
      default:
        return null;
    }
  }

  /**
   * Generate structure tree
   */
  generateStructureTree(directories) {
    const lines = ['├── src/'];

    directories.slice(0, 15).forEach((dir, i) => {
      if (!dir.startsWith('src/')) return;
      const parts = dir.split('/');
      const indent = '│   ' + '  '.repeat(parts.length - 2);
      lines.push(`${indent}├── ${parts[parts.length - 1]}/`);
    });

    return lines.join('\n');
  }

  /**
   * Generate directory table
   */
  generateDirectoryTable(directories) {
    const table = directories.slice(0, 20).map((dir) => {
      const purpose = this.guessDirectoryPurpose(dir);
      return `| \`${dir}/\` | ${purpose} |`;
    });

    return table.join('\n');
  }

  /**
   * Guess directory purpose
   */
  guessDirectoryPurpose(dir) {
    const purposes = {
      src: 'Source code',
      lib: 'Library code',
      components: 'UI components',
      pages: 'Page routes',
      api: 'API endpoints',
      services: 'Business logic',
      utils: 'Utility functions',
      hooks: 'React hooks',
      types: 'Type definitions',
      styles: 'Stylesheets',
      assets: 'Static assets',
      public: 'Public files',
      tests: 'Test files',
      docs: 'Documentation',
      config: 'Configuration',
      scripts: 'Build scripts',
      models: 'Data models',
      controllers: 'Request handlers',
      middleware: 'Middleware',
      routes: 'Route definitions',
    };

    const baseName = dir.split('/').pop();
    return purposes[baseName] || 'Application code';
  }

  /**
   * Get install command
   */
  getInstallCommand(analysis) {
    const pm = analysis.techStack.packageManager || 'npm';
    return `${pm} install`;
  }

  /**
   * Get dev command
   */
  getDevCommand(analysis) {
    return 'npm run dev';
  }

  /**
   * Get test command
   */
  getTestCommand(analysis) {
    return 'npm test';
  }
}

module.exports = { ContentGenerator };
